# -*- coding: utf-8 -*-
"""LOAN CHECK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ieg8AIxwelg4oGVt6zyNZr7fxiPosFs3

Importing necessary libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
!pip install seaborn
import seaborn as sns

# %matplotlib inline

dataset_train = pd.read_csv("/content/loan-train.csv")

dataset_train.head()

"""Data Exploration"""

dataset_train.shape

dataset_train.info()

dataset_train.describe()

"""Comparing correlation between better 'Credit History' and 'Loan Approval'"""

pd.crosstab(dataset_train['Credit_History'], dataset_train['Loan_Status'], margins=True)

dataset_train.boxplot(column='ApplicantIncome')

dataset_train['ApplicantIncome'].hist(bins=20)

dataset_train['CoapplicantIncome'].hist(bins=20)

dataset_train.boxplot(column='ApplicantIncome', by= "Education")

dataset_train.boxplot(column='LoanAmount')

dataset_train['LoanAmount'].hist(bins=20)

dataset_train['LoanAmount_log']=np.log(dataset_train['LoanAmount'])
dataset_train['LoanAmount_log'].hist(bins=20)

dataset_train.isnull().sum()

"""Replace missing values with mode in categorical variables"""

dataset_train['Gender'].fillna(dataset_train['Gender'].mode()[0], inplace=True)

dataset_train['Married'].fillna(dataset_train['Married'].mode()[0], inplace=True)

dataset_train['Dependents'].fillna(dataset_train['Gender'].mode()[0], inplace=True)

dataset_train['Self_Employed'].fillna(dataset_train['Self_Employed'].mode()[0], inplace=True)

dataset_train['Credit_History'].fillna(dataset_train['Credit_History'].mode()[0], inplace=True)

dataset_train['Loan_Amount_Term'].fillna(dataset_train['Loan_Amount_Term'].mode()[0], inplace=True)

"""Replace missing values with mean for numerical variables"""

dataset_train.LoanAmount = dataset_train.LoanAmount.fillna(dataset_train.LoanAmount.mean())
dataset_train.LoanAmount_log = dataset_train.LoanAmount_log.fillna(dataset_train.LoanAmount_log.mean())

dataset_train.isnull().sum()

dataset_train['TotalIncome']=dataset_train['ApplicantIncome'] + dataset_train['CoapplicantIncome']
dataset_train['TotalIncome_log']=np.log(dataset_train['TotalIncome'])

dataset_train['TotalIncome_log'].hist(bins=20)

correlation_matrix = dataset_train[['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Credit_History']].corr()

# Display the correlation matrix
correlation_matrix

correlation_matrix = dataset_train[['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Credit_History']].corr()

# Set up the matplotlib figure
plt.figure(figsize=(10, 8))

# Draw the heatmap with the mask and correct aspect ratio
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm', square=True, linewidths=.5, cbar_kws={"shrink": .5})

# Show the plot
plt.show()

dataset_train.head()

x=dataset_train.iloc[:,np.r_[1:5,9:11,13:15]].values #dependent
y=dataset_train.iloc[:,12].values #independent

x

y

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.2, random_state=0)

print(x_train)

"""Label Encoder to convert categorical text to numeric"""

from sklearn.preprocessing import LabelEncoder
labelencoder_x = LabelEncoder()

for i in range(0,5):
  x_train[:,i]=labelencoder_x.fit_transform(x_train[:,i])

x_train[:,7]= labelencoder_x.fit_transform(x_train[:,7])

x_train

labelencoder_y=LabelEncoder()
y_train= labelencoder_y.fit_transform(y_train)

y_train

for i in range(0,5):
  x_test[:,i]=labelencoder_x.fit_transform(x_test[:,i])

x_test[:,7]= labelencoder_x.fit_transform(x_test[:,7])

labelencoder_y=LabelEncoder()
y_test= labelencoder_y.fit_transform(y_test)

x_test

y_test

"""Data Scaling (data attributes has different range)"""

from sklearn.preprocessing import StandardScaler
ss=StandardScaler()
x_train=ss.fit_transform(x_train)
x_test=ss.fit_transform(x_test)

from sklearn.tree import DecisionTreeClassifier
DTClassifier= DecisionTreeClassifier(criterion='entropy', random_state=0)
DTClassifier.fit(x_train,y_train)

y_pred=DTClassifier.predict(x_test)
y_pred

from sklearn import metrics
print('The accuracy of decision tree is: ', metrics.accuracy_score(y_pred,y_test))

from sklearn.naive_bayes import GaussianNB
NBClassifier = GaussianNB()
NBClassifier.fit(x_train,y_train)

y_pred=NBClassifier.predict(x_test)

y_pred

print('The accuracy of NB is: '), metrics.accuracy_score(y_pred,y_test)

testdata=pd.read_csv('/content/loan-train.csv')

testdata.head()

testdata.isnull().sum()

testdata['Gender'].fillna(testdata['Gender'].mode()[0],inplace=True)
testdata['Dependents'].fillna(testdata['Dependents'].mode()[0],inplace=True)
testdata['Self_Employed'].fillna(testdata['Self_Employed'].mode()[0],inplace=True)
testdata['Loan_Amount_Term'].fillna(testdata['Loan_Amount_Term'].mode()[0],inplace=True)
testdata['Credit_History'].fillna(testdata['Credit_History'].mode()[0],inplace=True)

testdata.boxplot(column='LoanAmount')

testdata.boxplot(column='ApplicantIncome')

testdata.LoanAmount=testdata.LoanAmount.fillna(testdata.LoanAmount.mean())

testdata['LoanAmount_log']=np.log(testdata['LoanAmount'])

testdata.isnull().sum()

testdata['TotalIncome']= testdata['ApplicantIncome']+testdata['CoapplicantIncome']
testdata['TotalIncome_log']=np.log(testdata['TotalIncome'])

testdata.head()

"""Changing text to binary"""

test=testdata.iloc[:,np.r_[1:5,9:11,13:15]].values

for i in range(0,5):
  test[:,i]=labelencoder_x.fit_transform(test[:,i])

test[:,7]= labelencoder_x.fit_transform(test[:,7])

test

test=ss.fit_transform(test)

pred=NBClassifier.predict(test)

pred

predictions = np.array(pred)

df = pd.read_csv("/content/loan-test.csv")

df = dataset_train['Loan_ID'].values  # Make sure 'Loan_ID' is the correct column name
# Check if the number of predictions matches the number of Loan_IDs
if len(predictions) != len(df):
    print("Error: The number of predictions does not match the number of Loan IDs.")
else:
    # Pair each Loan ID with its prediction
    loan_to_prediction = pd.DataFrame({
        'Loan_ID': df,
        'Prediction': predictions
    })

    # Print or save the result
    print(loan_to_prediction)

import pandas as pd

# Set the option to display all rows (replace 'None' with a specific number if needed)
pd.set_option('display.max_rows', None)

# Assuming 'loan_to_prediction' is your DataFrame
print(loan_to_prediction)

# Reset display option if needed
pd.reset_option('display.max_rows')